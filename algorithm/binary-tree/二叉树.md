# 二叉树
>二叉树基础知识：[数据结构-二叉树](https://github.com/kerwin-ly/Blog/blob/master/data-structure/%E4%BA%8C%E5%8F%89%E6%A0%91.md)

要了解二叉树，一定得了解二叉树的几种遍历方式：

[二叉树的递归遍历（前序、中序、后序）(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86(%E7%AE%80%E5%8D%95).md)

[二叉树的迭代遍历（前序、中序、后序）(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86(%E4%B8%AD%E7%AD%89).md)

[二叉树的层序遍历(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86(%E4%B8%AD%E7%AD%89).md)
## 相关题目

### 递归处理树节点

[226. 翻转二叉树(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md)

[101. 对称二叉树(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md)

[104. 二叉树的最大深度(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6(%E7%AE%80%E5%8D%95).md)

[111. 二叉树的最小深度(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6(%E7%AE%80%E5%8D%95).md)

### 完全二叉树
[222. 完全二叉树的节点个数(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/222.%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0(%E4%B8%AD%E7%AD%89).md)

[110.平衡二叉树(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md)

### 递归+回溯 处理路径问题

[257. 二叉树的所有路径(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84(%E7%AE%80%E5%8D%95).md)

[129. 求根节点到叶节点数字之和(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C(%E4%B8%AD%E7%AD%89).md)

[404. 左叶子之和(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/404.%20%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C(%E7%AE%80%E5%8D%95).md)

[112. 路径总和(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C(%E7%AE%80%E5%8D%95).md)

### 层序遍历

[513. 找树左下角的值(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/513.%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC(%E4%B8%AD%E7%AD%89).md)
### 构建二叉树

[106. 从中序与后序遍历序列构造二叉树(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91(%E4%B8%AD%E7%AD%89).md)

[654. 最大二叉树(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/654.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91(%E4%B8%AD%E7%AD%89).md)

## 总结

### 关于二叉树的遍历

#### 递归遍历
在递归遍历二叉树时，我们应该明确以下3个步骤：

**1. 确定递归的入参和返回结果**

根据题目，我们需要先确定递归函数的入参是什么？简单分为以下情况：

* 第一种：入参只有当前根节点，每次递归的结果不影响下一次递归。如[226. 翻转二叉树(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md)这道题目

* 第二种：如果要判断树是否对称/相等 等情况时，我们需要将左子树和右子树进行比较，那么入参一定至少有两个。分别对应左子树和右边子树。如：[101. 对称二叉树(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md)

* 第三种：每一次递归需要依赖上一次递归的结果，那么每次递归的结果，需要被return出来。如：[104. 二叉树的最大深度(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6(%E7%AE%80%E5%8D%95).md)

* 第四种：递归时，需要通过参数来体现`回溯`的思想。当探索的路径不满足条件时，需要返回上一步，走另外一条分支。如：[257. 二叉树的所有路径(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84(%E7%AE%80%E5%8D%95).md)、[129. 求根节点到叶节点数字之和(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C(%E4%B8%AD%E7%AD%89).md)

**2. 确定递归的终止条件**

终止条件可以简单的分为三种： 

* 第一种：判断当前节点是否存在，不存在则return。如[226. 翻转二叉树(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md)这道题目，由于需要对所有节点做处理。所以一直遍历到了空节点为止。 

```js
traversal(node) {
  if (!node) {
    return;
  }
}
```

* 第二种：如果题目中明确表示求相关**叶子节点**的信息，那么我们的退出条件应该到叶子节点即可，不让递归中出现空节点。如[404. 左叶子之和(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/404.%20%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C(%E7%AE%80%E5%8D%95).md)、[129. 求根节点到叶节点数字之和(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C(%E4%B8%AD%E7%AD%89).md)、[257. 二叉树的所有路径(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84(%E7%AE%80%E5%8D%95).md)。为了保证遍历中不存在空节点，我们在是否进行下一次递归时，也需要加上为空判断。如：`node.left && traversal(node.left)`;
```js
traversal(node) {
  if (node.left === null && node.right === null) {
    return;
  }

  node.left && traversal(node.left);
  node.right && traversal(node.right);
}
```

第三种：当递归过程中，满足了要求条件时，需要立刻终止递归，返回当前结果。如：[112. 路径总和(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C(%E7%AE%80%E5%8D%95).md)

**3. 编写递归函数的单层逻辑，确定下一次递归的入参**

### 迭代遍历
在做二叉树的迭代遍历之前，我们必须知道**递归实际就是一种栈的结构实现**，能用递归实现的逻辑，用栈一样能实现。
>递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

在迭代遍历二叉树，由于有`中序`和`后序`遍历，所以不能严格的按照"后进先出"的逻辑来做。我们需要加一个**标志位**，来判断该节点是否可以出栈并添加结果数组中。

代码实现：[二叉树的迭代遍历（前序、中序、后序）(简单)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86(%E4%B8%AD%E7%AD%89).md)

### 层序遍历
层序遍历逻辑比较清晰，由于结果是按照`先进先出`的顺序弹出的。所以，我们利用`队列`来处理。

从根节点开始，逐层向下遍历。每一层遍历，按照`先进先出`的顺序，挨个弹出队头节点，再将队头节点的左右子节点也push到队列尾部。用作下一层遍历使用。以此循环，**直到队列为空为止**。

代码实现：[二叉树的层序遍历(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86(%E4%B8%AD%E7%AD%89).md)

### 二叉树的构建

通过数组构建二叉树的题目中，如：[106. 从中序与后序遍历序列构造二叉树(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91(%E4%B8%AD%E7%AD%89).md)、[654. 最大二叉树(中等)](https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/654.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91(%E4%B8%AD%E7%AD%89).md)，我们需要需要以下几点：

1. 当需要“截取”数组，作为左子树和右子树时。不要通过`splice`方法去将原数组截断修改，这会浪费一定的空间和时间。建议的做法是通过左右指针固定一个“区间”。在原数组的某个区间中，去做树的构建操作。

2. 通过数组构建树时，结合第一步不改变原数组，也不生成新数组的前提下。递归方法的入参一般是左右指针。换一个说法，也可以说是，每一次递归构建树时，需要确定是从数组的哪个范围来构建。当左指针下标大于右指针下标时，退出递归

3. 选出子树的根节点后，构建左子树和右子树时，注意不能取到中间节点。这和`二分法`的取值类似。