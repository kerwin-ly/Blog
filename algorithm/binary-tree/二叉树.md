# 二叉树

> 二叉树基础知识：[数据结构-二叉树](https://github.com/kerwin-ly/Blog/blob/master/data-structure/%E4%BA%8C%E5%8F%89%E6%A0%91.md)

要了解二叉树，一定得了解二叉树的几种遍历方式：

[二叉树的递归遍历（前序、中序、后序）](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86(%E7%AE%80%E5%8D%95).md>)

[二叉树的迭代遍历（前序、中序、后序）](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86(%E4%B8%AD%E7%AD%89).md>)

[二叉树的层序遍历](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86(%E4%B8%AD%E7%AD%89).md>)

## 相关题目

### 递归处理树节点

[226. 翻转二叉树](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md>)

[101. 对称二叉树](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md>)

[104. 二叉树的最大深度](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6(%E7%AE%80%E5%8D%95).md>)

[111. 二叉树的最小深度](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/111.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%B0%8F%E6%B7%B1%E5%BA%A6(%E7%AE%80%E5%8D%95).md>)

[236. 二叉树的最近公共祖先](https://github.com/kerwin-ly/Blog/blob/main/algorithm/binary-tree/236.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88.md)

### 完全二叉树

[222. 完全二叉树的节点个数](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/222.%20%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%8A%82%E7%82%B9%E4%B8%AA%E6%95%B0(%E4%B8%AD%E7%AD%89).md>)

[110.平衡二叉树](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/110.%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md>)

### 递归+回溯 处理路径问题

[257. 二叉树的所有路径](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84(%E7%AE%80%E5%8D%95).md>)

[129. 求根节点到叶节点数字之和](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C(%E4%B8%AD%E7%AD%89).md>)

[404. 左叶子之和](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/404.%20%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C(%E7%AE%80%E5%8D%95).md>)

[112. 路径总和](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C(%E7%AE%80%E5%8D%95).md>)

### 层序遍历

[513. 找树左下角的值](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/513.%20%E6%89%BE%E6%A0%91%E5%B7%A6%E4%B8%8B%E8%A7%92%E7%9A%84%E5%80%BC(%E4%B8%AD%E7%AD%89).md>)

### 构建二叉树

[106. 从中序与后序遍历序列构造二叉树](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91(%E4%B8%AD%E7%AD%89).md>)

[654. 最大二叉树](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/654.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91(%E4%B8%AD%E7%AD%89).md>)

### 二叉搜索树

[700.二叉搜索树中的搜索](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2(%E7%AE%80%E5%8D%95).md>)

[98. 验证二叉搜索树](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(%E4%B8%AD%E7%AD%89).md>)

[230. 二叉搜索树中第 K 小的元素](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0(%E4%B8%AD%E7%AD%89).md>)

[450. 删除二叉搜索树中的节点](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/450.%20%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9(%E4%B8%AD%E7%AD%89).md>)

### 其他

[208. 实现 Trie (前缀树)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/208.%20%E5%AE%9E%E7%8E%B0%20Trie%20(%E5%89%8D%E7%BC%80%E6%A0%91).md>)

## 总结

### 关于二叉树的遍历

#### 递归遍历

在递归遍历二叉树时，我们应该明确以下 3 个步骤：

**1. 确定递归的入参和返回结果**

根据题目，我们需要先确定递归函数的入参是什么？简单分为以下情况：

- 第一种：入参只有当前根节点，每次递归的结果不影响下一次递归。如[226. 翻转二叉树(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md>)这道题目

- 第二种：如果要判断树是否对称/相等 等情况时，我们需要将左子树和右子树进行比较，那么入参一定至少有两个。分别对应左子树和右边子树。如：[101. 对称二叉树(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/101.%20%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md>)

- 第三种：每一次递归需要依赖上一次递归的结果，那么每次递归的结果，需要被 return 出来。如：[104. 二叉树的最大深度(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/104.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6(%E7%AE%80%E5%8D%95).md>)

- 第四种：递归时，需要通过参数来体现`回溯`的思想。当探索的路径不满足条件时，需要返回上一步，走另外一条分支。如：[257. 二叉树的所有路径(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84(%E7%AE%80%E5%8D%95).md>)、[129. 求根节点到叶节点数字之和(中等)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C(%E4%B8%AD%E7%AD%89).md>)

**2. 确定递归的终止条件**

终止条件可以简单的分为三种：

- 第一种：判断当前节点是否存在，不存在则 return。如[226. 翻转二叉树(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/226.%20%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91(%E7%AE%80%E5%8D%95).md>)这道题目，由于需要对所有节点做处理。所以一直遍历到了空节点为止。

```js
traversal(node) {
  if (!node) {
    return;
  }
}
```

- 第二种：如果题目中明确表示求相关**叶子节点**的信息，那么我们的退出条件应该到叶子节点即可，不让递归中出现空节点。如[404. 左叶子之和(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/404.%20%E5%B7%A6%E5%8F%B6%E5%AD%90%E4%B9%8B%E5%92%8C(%E7%AE%80%E5%8D%95).md>)、[129. 求根节点到叶节点数字之和(中等)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/129.%20%E6%B1%82%E6%A0%B9%E8%8A%82%E7%82%B9%E5%88%B0%E5%8F%B6%E8%8A%82%E7%82%B9%E6%95%B0%E5%AD%97%E4%B9%8B%E5%92%8C(%E4%B8%AD%E7%AD%89).md>)、[257. 二叉树的所有路径(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/257.%20%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84(%E7%AE%80%E5%8D%95).md>)。为了保证遍历中不存在空节点，我们在是否进行下一次递归时，也需要加上为空判断。如：`node.left && traversal(node.left)`;

```js
traversal(node) {
  if (node.left === null && node.right === null) {
    return;
  }

  node.left && traversal(node.left);
  node.right && traversal(node.right);
}
```

第三种：当递归过程中，满足了要求条件时，需要立刻终止递归，返回当前结果。如：[112. 路径总和(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/112.%20%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C(%E7%AE%80%E5%8D%95).md>)

**3. 编写递归函数的单层逻辑，确定下一次递归的入参**

### 迭代遍历

在做二叉树的迭代遍历之前，我们必须知道**递归实际就是一种栈的结构实现**，能用递归实现的逻辑，用栈一样能实现。

> 递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

在迭代遍历二叉树，由于有`中序`和`后序`遍历，所以不能严格的按照"后进先出"的逻辑来做。我们需要加一个**标志位**，来判断该节点是否可以出栈并添加结果数组中。

代码实现：[二叉树的迭代遍历（前序、中序、后序）(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86(%E4%B8%AD%E7%AD%89).md>)

### 层序遍历

层序遍历逻辑比较清晰，由于结果是按照`先进先出`的顺序弹出的。所以，我们利用`队列`来处理。

从根节点开始，逐层向下遍历。每一层遍历，按照`先进先出`的顺序，挨个弹出队头节点，再将队头节点的左右子节点也 push 到队列尾部。用作下一层遍历使用。以此循环，**直到队列为空为止**。

代码实现：[二叉树的层序遍历(中等)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86(%E4%B8%AD%E7%AD%89).md>)

### 二叉树的构建

通过数组构建二叉树的题目中，如：[106. 从中序与后序遍历序列构造二叉树(中等)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/106.%20%E4%BB%8E%E4%B8%AD%E5%BA%8F%E4%B8%8E%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91(%E4%B8%AD%E7%AD%89).md>)、[654. 最大二叉树(中等)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/654.%20%E6%9C%80%E5%A4%A7%E4%BA%8C%E5%8F%89%E6%A0%91(%E4%B8%AD%E7%AD%89).md>)，**一定要想好递归的参数是什么？，在这里，我们的入参是一个数组区间。**。每次递归时，根据这个数组区间，构建一颗子树，然后通过`left`,`right`属性将子树连接起来。同时我们还需要注意以下几点：

1. 当需要“截取”数组，作为左子树和右子树时。不要通过`splice`方法去将原数组截断修改，这会浪费一定的空间和时间。建议的做法是通过左右指针固定一个“区间”。在原数组的某个区间中，去做树的构建操作。

2. 通过数组构建树时，结合第一步不改变原数组，也不生成新数组的前提下。递归方法的入参一般是左右指针。换一个说法，也可以说是，每一次递归构建树时，需要确定是从数组的哪个范围来构建。当左指针下标大于右指针下标时，退出递归

3. 选出子树的根节点后，构建左子树和右子树时，注意不能取到中间节点。这和`二分法`的取值类似。

### 二叉搜索树

二叉搜索树的一大特性就是：**树的根节点的值一定大于其左子树所有节点，小于右子树的所有节点**。如：[98. 验证二叉搜索树(中等)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/98.%20%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91(%E4%B8%AD%E7%AD%89).md>)

根据这个特性，我们在二叉搜索树查找某个节点的时间复杂度为 O(logn)。如：[700.二叉搜索树中的搜索(简单)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/700.%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E6%90%9C%E7%B4%A2(%E7%AE%80%E5%8D%95).md>)

同时，通过这个特性，我们也可以推断出：**二叉搜索树的中序遍历，一定是一个递增的序列**。在解决求第 k 大（小）的节点时，能很快得到结果。 如：[230. 二叉搜索树中第 K 小的元素(中等)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/230.%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0(%E4%B8%AD%E7%AD%89).md>)

在删除二叉搜索树的节点时，我们要注意保证二叉搜索树的特性。需要将删除节点的**左子树的最大节点** 或**右子树的最小节点**替换当前节点。如：[450. 删除二叉搜索树中的节点(中等)](<https://github.com/kerwin-ly/Blog/blob/master/algorithm/binary-tree/450.%20%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9(%E4%B8%AD%E7%AD%89).md>)
