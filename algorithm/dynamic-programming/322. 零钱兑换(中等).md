### 322. 零钱兑换(中等)

> LeetCode 地址：https://leetcode.cn/problems/coin-change/

### 题解

做这道题，我们一定要跳出思维惯性，在之前的题目中，我们定义dp数组，i仅仅是作为一个下标值，而没有实际意义。而这道题，**i具备实际意义，其可以被看成amount**。

1. 确定 dp 数组的下标和值

在本题中，求解的是`凑成金额amount的最小硬币个数`。比如：金额是 11，硬币是 1，2，5 时。我们要如何推出这个凑成这个金额的最小硬币个数呢？

直观的看，我们很容易得到答案，由`5 + 5 + 1`。其中`5 + 5`就是凑成金额 10 的最小硬币个数，而`1`就是凑成金额 1 的最小硬币个数。

那么我们自然想到，应该把组成`0 - 11`金额的最小硬币个数都推导出来。

`dp[i]`最终就表示为：凑成金额 i 的最小硬币个数

2. 确定状态转移方程和初始值

dp 数组的初始值为`dp[0] = 0`。金额 0 的最小组成硬币个数为 0。由于题目求的是最小硬币个数，我们可以把初始值都设置为无穷大`Infinity`，便于后面取较小值。

还是根据题目举例。当金额为`11`时，由于硬币有`1, 2, 5`三个。那么它可以由`10 + 1`、`9 + 2`和`6 + 5`组成。那么我们比较`dp[10]`、`dp[9]`和`dp[6]`，获取较小值。然后`dp[x] + 1`（加 1 是因为在原有基础上还要要取`硬币1,2,5`的其中一个才能组成当前`dp[11]`），就是当前的`dp[11]`。

所以，最终确定状态转移方程：

```js
// j 表示遍历coins硬币的下标
// i - coins[j]用于获取“是哪个金额”加上当前硬币就能获得当前金额i，求出组成它的最小硬币数量
dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
```

3. 确定遍历顺序
   从前往后

```js
/**
 * @param {number[]} coins
 * @param {number} amount
 * @return {number}
 */
var coinChange = function (coins, amount) {
  let dp = new Array(amount + 1).fill(Infinity); // 初始化数组amount+1的长度，额外增加下标为0的情况
  dp[0] = 0;

  for (let i = 0; i < dp.length; i++) {
    // dp[i]表示凑成总金额i的最小硬币个数
    for (let j = 0; j < coins.length; j++) {
      // 如果当前总额i小于当前硬币的值，当前硬币无法凑成总额
      if (i - coins[j] < 0) {
        continue;
      }
      dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1); // dp[i - coins[j]]用于获取哪个金额加上当前硬币，即可等于当前金额i。由于在之前金额上加上了一枚硬币，所以还要加1。就得到
    }
  }
  return dp[amount] === Infinity ? -1 : dp[amount];
};
```
