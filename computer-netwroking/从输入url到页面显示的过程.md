# 从输入url到页面显示的过程

面试中，我们常常会被问到：从输入url到页面显示，中间发生了什么？

之前，我对这个问题一直是一知半解的状态，不够深入。于是，我利用闲暇时间，阅读了[《计算机网络自顶向下方法-第七版》](https://github.com/kerwin-ly/books/blob/main/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95%E7%AC%AC%E4%B8%83%E7%89%88.pdf)的书籍，结合[中科大郑烇老师的教学视频](https://www.bilibili.com/video/BV1JV411t7ow?from=search&seid=18425226436912830366&spm_id_from=333.337.0.0)，对计算机网络的知识有了更深刻的理解，便有了这篇文章的分享。如果你想快速了解这本书相关的知识点，可以看下我之前写的[读书笔记](https://github.com/kerwin-ly/Blog/blob/main/computer-netwroking/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md)

下面，我们进入正题，来了解 **从输入url到页面显示，中间发生了什么？**

## 1. 域名解析

域名解析是将域名转换为对应的IP的过程。

### 1.1 缓存机制

在域名解析前，首先会从浏览器缓存、系统缓存、路由器缓存、ISP缓存中递归的查找域名对应的IP地址。如果上述缓存中，均没有找到对应的IP地址，则发起域名解析请求。

### 1.2 域名的层级关系

在说域名解析前，我们需要了解DNS服务器的层级关系，其主要分为根DNS服务器、顶级域DNS服务器、权威DNS服务器。

* 根DNS服务器：是互联网域名解析系统（DNS）中最高级别的域名服务器，负责返回顶级域的域名服务器地址

* 顶级域DNS服务器：每个顶级域（如：com、org、net、edu和gov）和国家的顶级域（如：uk、fr、ca和jp），都有TLD服务器（或服务器集群）。提供权威DNS服务器 IP地址

* 权威DNS服务器：在因特网上具有公共可访问主机 (如Web服务器)的组织机构必须提供公共可访问的DNS记录， 这些记录将这些主机名
字映射为IP地址。而一个组织机构`权威DNS服务器`收藏了这些DNS记录。其提供了域名和`IP`地址的映射关系。

### 1.3 域名解析流程

下面，我们通过一个`www.example.com`的来对细节进行阐述：

1. 生成一个DNS查询报文，发送到`本地DNS服务器`，这一般由用户的互联网服务提供商 (ISP) 进行管理，例如有线 Internet 服务提供商、DSL 宽带提供商或公司网络。

2. ISP 的 `本地DNS服务器` 将 含有 www.example.com 主机名的查询报文 发送到 `根DNS服务器`。该`根DNS服务器`注意到`.com`前缀后，将 负责`.com`的`顶级域DNS服务器`的IP地址列表返回。

3. 获取到`顶级域DNS服务器`对应的IP地址列表后，ISP再次向这些`顶级域DNS服务器`之一发送查询报文。该`顶级域DNS服务器`注意到`example.com`前缀后，用`权威DNS服务器`的IP地址进行响应。

4. ISP 的`本地DNS服务器`选择一个`权威DNS服务器`（ Amazon Route 53 名称服务器）继续发送查询报文。

5. `权威服务器`（Amazon Route 53 名称服务器）在 example.com 托管区域中查找 www.example.com 记录并获得对应的IP地址，并将 IP 地址返回至 `本地DNS服务器`。

![域名解析-迭代](https://raw.githubusercontent.com/kerwin-ly/Blog/main/assets/imgs/internet/dns-analyze.png)

在获取到域名对应的IP后，客户端便可以向服务器发起HTTP请求了。

## 2. HTTP请求报文

客户端发起资源请求，进行进程之间的通信。HTTP协议是在应用层工作的，其完成了对HTTP报文等的封装。然后通过套接字接口`Socket Api`向传输层发送`数据内容`和`TCP Socket`。（Socket Api需要的参数是：发送端IP + 发送端端口 + 目标IP + 目标端口。这些参数一般封装于`TCP Socket`中，`TCP Socket`是四元组的一个具有本地意义的标识，代表两个特定进程的会话关系。所以，每次层间接口的请求，带上`TCP Socket`即可。在最后到达服务端的应用层后，其可以通过查询`TCP Socket表`解析该`套接字`，获取里面的信息）

## 3. TCP报文段封装

### 3.1 TCP 三次握手

1. 客户端**随机**生成一个客户端序列号`seq = client_isn`（isn, initial sequence number），发送该序列号和`SYN`报文（请求建立连接标识）到服务端。（第一次握手，表明客户端能正常发送，服务端能正常接收）

2. 服务端收到客户端请求后，对客户端序列号进行确认，并生成对应的`ack`确认报文，表明服务端收到了对应的请求。接着生成服务端序列号`seq = server_isn`，用于探听客户端是否能正常接收。最后将`ack`确认报文、`seq`服务端序列号和`SYN`报文一起发送给客户端（第二次握手，表明服务端能正常接收、发送，客户端能正常发送。**注意：这时候服务端还没有收到服务端序列号对应的确认字段，所以不能表明客户端能正常接收，即不能两次握手就开始发送数据**）

3. 客户端收到服务端的返回后，对客户端序列号进行确认，生成确认报文`ack`。然后生成新的客户端序列号一并发送到服务端。服务端收到后，连接建立。（第三次握手，表明了服务端和客户端都具有正常接收、发送能力）

![tcp-connect](https://raw.githubusercontent.com/kerwin-ly/Blog/main/assets/imgs/internet/tcp-connect.png)

针对TCP连接，我们可以思考一下如下几个问题。

#### TCP可以两次握手就建立连接么？

不行。因为TCP是全双工通信，客户端和服务端分别扮演了“发送者”和“接收者”的角色。三次握手的目的是**保证双方都有发送和接收的能力。**

我们思考下，如果只有两次握手。当客户端发送SYN报文表明客户端有`发送能力`，报文了到了客户端后，从服务端发送ACK确认报文，表明服务端有`接收能力`。发送SYN报文，表明服务端也有`发送能力`。但仅两次握手，无法保证客户端有`接收能力`。所以有了三次握手，来确认客户端也有`接收能力`。这避免了数据传输丢包的可能，说明了其可靠性传输。

如果仅两次握手，也可能导致无效的连接，浪费资源的情况。如：客户端发送一次请求后，报文消失在了网络中。到了超时时间后，客户端又发起了一次请求，这次请求建立了双方的通信，进行数据交换后，正常关闭了连接。但过了许久，第一次发送的报文到达了服务端，服务端错误的以为客户端需要建立连接，所以返回给客户端确认报文，建立了双方连接。此时，客户端是不知情的，但服务端一直在等待客户端的数据发送。造成了资源浪费。

#### 初始序列号（ISN, Initial Sequence Number）是固定的吗？

不是。ISN随时间而变化，因此每个连接都将具有不同的ISN。ISN可以看作是一个32比特的计数器，每4ms加1 。这样选择序号的目的在于防止在网络中被延迟的分组在以后又被传送，而导致某个连接的一方对它做错误的解释。

三次握手的其中一个重要功能是客户端和服务端交换 ISN(Initial Sequence Number)，以便让对方知道接下来接收数据的时候如何按序列号组装数据。如果 ISN 是固定的，攻击者很容易猜出后续的确认号，因此 ISN 是动态生成的。

### 3.2 封装TCP报文段
说到封装TCP报文段，我们首先得知道TCP报文段结构，如下：

>MTU：一个网络包的最大长度，以太网中一般为 1500 字节。
>MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

32比特的`序号字段(sequence window field)`：报文段载荷的

32比特的`确认号字段(acknowledgement number field)`

16比特的`接收窗口字段(receive window field)`：用于流量控制，指示愿意接收的字节数量

4比特的`首部长度字段(header length field)`

`选项字段`：用于发送方与接收方协商最大报文长度(MSS)时作为协调因子使用

数据字段

6比特的`标志字段`：ACK => 确认字段，SYN => 表明请求连接，FIN => 拆除链接，RST => 复位，用来异常的关闭连接

![tcp-structure](https://raw.githubusercontent.com/kerwin-ly/Blog/main/assets/imgs/internet/tcp-body1.jpeg)

数据会被以 MSS 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 网络层IP 模块来发送数据。
 
## 4. IP报文封装

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。

首先，我们来看下 IP 报文头部的结构：

![ip-structure](https://raw.githubusercontent.com/kerwin-ly/Blog/main/assets/imgs/internet/ip-body.jpeg)

在 IP 协议里面需要有源地址 IP 和 目标地址 IP：

源地址IP，即是客户端输出的 IP 地址；
目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

当存在多个网卡时，即有多个输出的IP地址可选。这时，就需要根据路由表规则，将服务器的目标地址和源地址进行`与运算`匹配，来判断哪一个网卡作为源地址 IP。

确定完源IP地址后，开始封装IP头部，其结构如下：

![ip-structure](https://raw.githubusercontent.com/kerwin-ly/Blog/main/assets/imgs/internet/ip-body2.jpeg)

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。

MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。

获取发送方（即自身）的MAC地址比较简单，其MAC地址在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。

但获取接收方的MAC地址就比较麻烦了，知道接收方的IP地址后，需要通过`ARP 协议`在以太网中进行广播，去获取该IP地址对应的MAC地址，然后放在 ARP缓存中，便于下次直接获取。

此时的IP报文结构如下：

![ip-structure](https://raw.githubusercontent.com/kerwin-ly/Blog/main/assets/imgs/internet/ip-body3.jpeg)

## 5. 信号发送
网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电磁波信号/光信号，才能在网线/光缆等物质媒体上传输。

负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。

网卡驱动获取网络包之后，会将其复制到网卡内的缓存区中，接着会在其开头加上报头和`起始帧`分界符，在末尾加上用于检测错误的`帧`校验序列。在数据链路层，数据是以`帧`的形式传输的。

>起始帧分界符是一个用来表示包起始位置的标记
>末尾的 FCS（帧校验序列）用来检查包传输过程是否有损坏

最后网卡会将`帧`中的一个个比特转为电信号，通过网线发送出去。再由其他物理介质进行传输。

## 6. 服务端解析
从客户端完成了1-5步的封装，到了服务端则从5-1步进行解析。这里我们就不做过多描述了。

## 7. 页面渲染
页面的渲染主要分为以下几步：

### 7.1 构建DOM树

1. 首先，将服务端返回的一个个字节转换为我们平常看到的字符串，就是我们编写的代码。

2. 根据字符串信息，生成`Token`。`Token`可以标记当前是`起始节点`还是`终止节点`（如：`startTag html`和`endTag html`。）。如果`Token`标记的是`起始节点`就创建节点对象，如果是终止节点，则不创建。

3. 通过Token创建节点对象，同时确定节点的层级关系。（如：`[startTag-html startTag-body endTag-body endTag-html`]，这种结构就表明了其html节点是body节点的父节点）

注意：构建DOM的过程中，不是等所有`Token`都转换完成后再去生成节点对象，而是一边生成Token一边消耗Token来生成节点对象。

4. 构建DOM树。如果遇到图片之类的标签，会加载图片资源

### 7.2 构建CSSOM树
构建CSSOM的过程与构建DOM的过程非常相似，当浏览器接收到一段CSS，浏览器首先要做的是识别出Token，然后构建节点并生成CSSOM。

需要注意的是，CSS查找HTML元素是一个复杂且低效的事情。所以，DOM树要小，CSS尽量用id和class，千万不要过渡层叠下去。

如果在CSSOM树构建中，有背景图`background-image`，此时不会加载背景图的资源。而是在渲染render树时遍历CSS树过程中，才加载背景图的url。

### 7.3 构建渲染树

生成 DOM 树和 CSSOM 树以后，就需要将这两棵树组合为渲染树。

然而，它们并不会“一帆风顺”的合并。因为在渲染过程中，如果遇到`<script>`标签就会停止渲染。

浏览器的`GUI渲染线线程`和`JS引擎执行线程`，考虑到JS也是可以操作DOM和CSSOM的，未避免渲染冲突，两个线程是互斥的。

所以，当JS代码加载、解析、执行时，会阻塞DOM的构建，**同时还会让CSSOM也阻塞DOM的构建**。

在没有JS加载的前提下，DOM和CSSOM的构建是互不影响的，但有JS加载就不一样了。

这是因为JS不只是可以修改DOM，也可以修改样式。但不完整的CSSOM是无法使用的，所以需要等CSSOM构建完毕，才可以进行修改。所以，这就导致了**浏览器会先下载和构建CSSOM，然后执行JS，最后继续构建DOM**

### 7.4 布局和渲染

当浏览器生成渲染树后，会根据渲染树计算它们在设备视口(viewport)内的确切位置和大小（回流），然后将渲染树的每个节点都转换为屏幕上的实际像素（重绘）。

布局流程的输出是一个“盒模型”，它会精确地捕获每个元素在视口内的确切位置和尺寸，所有相对测量值都将转换为屏幕上的绝对像素。

布局完成后，浏览器会立即发出“Paint Setup”和“Paint”事件，将渲染树转换成屏幕上的像素。

至此，从输入url到页面渲染的过程就结束了。

## 总结

本文中，从输入url到页面渲染的过程主要分为两部分。

第一部分是关于计算机网络相关的知识：其中，我们着重讲到了DNS解析、TCP三次握手、TCP/IP 报文封装、ARP协议等。其实还有很多没有讲到的，如TCP相关的拥塞控制、分组重传机制、路由选择算法等等。如果你对这块感兴趣，可以看看文章头部提到的[中科大郑烇老师关于计算机网络的教学视频](https://www.bilibili.com/video/BV1JV411t7ow?from=search&seid=18425226436912830366&spm_id_from=333.337.0.0)。如果你觉得视频太长，也可以简单翻阅下我的[计算机网络读书笔记](https://github.com/kerwin-ly/Blog/blob/main/computer-netwroking/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md)

第二部分是关于浏览器的渲染机制。这也是作为一个前端来说，比较重要的知识。我们尤其是需要注意，当加载`<script>`标签后，渲染流程发生了哪些改变。

## 参考链接
[计算机网络自顶向下方法 第七版](https://github.com/kerwin-ly/Blog/blob/main/computer-netwroking/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%87%AA%E9%A1%B6%E5%90%91%E4%B8%8B%E6%96%B9%E6%B3%95-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.md)

[键入网址到网页显示，期间发生了什么？](https://xiaolincoding.com/network/1_base/what_happen_url.html)

[你不知道的浏览器页面渲染机制](https://juejin.cn/post/6844903815758479374#heading-2)
